# algorithms learning
## 算法学习记录

### [32个经典算法](http://www.infoq.com/cn/news/2012/08/32-most-important-algorithms)

#### A* 搜索算法
图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A*搜索算法是最佳优先搜索的范例。

#### 集束搜索
又名定向搜索，Beam Search——最佳优先搜索算法的优化。使用启发式函数评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的m个最符合条件的节点，m是固定数字——集束的宽度。

#### 二分查找
Binary Search——在线性数组中找特定值的算法，每个步骤去掉一半不符合要求的数据。
分支界定算法（Branch and Bound）——在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。

#### Buchberger算法
一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中高斯消元法的泛化。
数据压缩——采取特定编码方案，使用更少的字节数（或是其他信息承载单元）对信息编码的过程，又叫来源编码。

#### Diffie-Hellman密钥交换算法
一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。

#### Dijkstra算法
针对没有负值权重边的有向图，计算其中的单一起点最短算法。

#### 离散微分算法
（Discrete differentiation）

#### 动态规划算法
（Dynamic Programming）——展示互相覆盖的子问题和最优子架构算法

#### 欧几里得算法
（Euclidean algorithm）——计算两个整数的最大公约数。最古老的算法之一，出现在公元前300前欧几里得的《几何原本》。

#### 期望-最大算法
（Expectation-maximization algorithm，又名EM-Training）——在统计计算中，期望-最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。

#### 快速傅里叶变换
（Fast Fourier transform，FFT）——计算离散的傅里叶变换（DFT）及其反转。该算法应用范围很广，从数字信号处理到解决偏微分方程，到快速计算大整数乘积。

#### 梯度下降
（Gradient descent）——一种数学上的最优化算法。

#### 哈希算法
（Hashing）

#### 堆排序-ok
（Heaps）

#### Karatsuba乘法
需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于1962年。

#### LLL算法
（Lenstra-Lenstra-Lovasz  lattice reduction）——以格规约（lattice）基数为输入，输出短正交向量基数。LLL算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的RSA加密等等。

#### 最大流量算法
（Maximum flow）——该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流-最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。

#### 合并排序-ok
（Merge Sort）

#### 牛顿法
（Newton's method）——求非线性方程（组）零点的一种重要的迭代法。

#### Q-learning学习算法
这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。

#### 两次筛法
（Quadratic Sieve）——现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法Number Field Sieve）。对于110位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。

#### RANSAC
——是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。
RSA——公钥加密算法。首个适用于以签名作为加密的算法。RSA在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。

#### Schönhage-Strassen算法
——在数学中，Schönhage-Strassen算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。

#### 单纯型算法
（Simplex Algorithm）——在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。

#### 奇异值分解
（Singular value decomposition，简称SVD）——在线性代数中，SVD是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解最小二乘法问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。

#### 求解线性方程组
（Solving a system of linear equations）——线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯—约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。

#### Strukturtensor算法
应用于模式识别领域，为所有像素找出一种计算方法，看看该像素是否处于同质区域（ homogenous region），看看它是否属于边缘，还是是一个顶点。

#### 合并查找算法
（Union-find）——给定一组元素，该算法常常用来把这些元素分为多个分离的、彼此不重合的组。不相交集（disjoint-set）的数据结构可以跟踪这样的切分方法。合并查找算法可以在此种数据结构上完成两个有用的操作：
查找：判断某特定元素属于哪个组。
合并：联合或合并两个组为一个组。

#### 维特比算法
（Viterbi algorithm）——寻找隐藏状态最有可能序列的动态规划算法，这种序列被称为维特比路径，其结果是一系列可以观察到的事件，特别是在隐藏的Markov模型中。

### 排序算法
各个算法特点总结：[http://amao12580.github.io/index/#排序算法的特点](http://amao12580.github.io/index/#排序算法的特点)

#### 1. 合并排序算法
* 思路：
* 将数组按长度切分成均匀的碎片，直到每个碎片数组长度不超过2
* 每个碎片数组进行排序
* 合并碎片数组，每两个碎片数组进行计算，总是两个起始元素进行比较，将小的元素迁移到新数组

#### 2. 选择排序算法
* 思路：
* 在第i次迭代中，在剩下的(即未排序的)元素中找到最小的元素
* 将第i个元素与最小的元素交换位置

#### 3. 插入排序算法
*  思路：
* 在第i次迭代中，将第i个元素与每一个它左边且比它大的的元素交换位置

#### 4. 希尔排序算法
* 对插入排序的改良
* 按照不同步长对元素进行插入排序

#### 5. 快速排序算法
* 对归并排序的改良
* 将二分之一切分改为按基数进行切分为两部分，一部分都比基数小，另一部分都比基数要大。
* 在每部分中，选取新基数，再次进行按基数切分，直到所有数据有序。

#### 6. 堆排序算法
* 借用完全二叉树的思想
* 设定数组初始长度为N，将数组调整为最大堆，最大堆的根节点是最大值。
* 根节点位于数组首部，O(0)
* 将这个最大值与O(N-1)交换
* 将数组的遍历范围减一，即:N--
* 在0到N之间重复上述过程

#### 7.计数排序算法
* 一种特殊的桶排序，按照每个待排序的数值进行分桶
* 找出待排序的数组中最大和最小的元素
* 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
* 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
* 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

#### 8.桶排序算法
* 桶排序是计数排序的变种，把计数排序中相邻的m个"小桶"放到一个"大桶"中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。
* 基本思想：
* 桶排序假设序列由一个随机过程产生，该过程将元素均匀而独立地分布在区间[0,1)上。我们把区间[0,1)划分成n个相同大小的子区间，称为桶。将n个记录分布到各个桶中去。
* 如果有多于一个记录分到同一个桶中，需要进行桶内排序。最后依次把各个桶中的记录列出来记得到有序序列。
* 效率分析：
* 桶排序的平均时间复杂度为线性的O(N+C)，其中C为桶内快排的时间复杂度。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。
* 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。

#### 9. 基数排序算法
* 将所有待比较数值(注意,必须是正整数)统一为同样的数位长度,数位较短的数前面补零.
* 从最低位开始, 依次进行一次稳定排序.
* 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列.

#### 10.冒泡排序算法
* 设数组长度为N。步骤如下
* 1．比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。
* 2．这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。
* 3．N=N-1，如果N不为0就重复前面二步，否则排序完成。

#### 11.鸡尾酒排序算法
* 冒泡排序的轻微变形。不同的地方在于，鸡尾酒排序是从低到高然后从高到低来回排序，而冒泡排序则仅从低到高去比较序列里的每个元素。
* 他可比冒泡排序的效率稍微好一点，原因是冒泡排序只从一个方向进行比对(由低到高)，每次循环只移动一个项目。