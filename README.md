# algorithms learning
## 算法学习记录

### 32个经典算法

### 排序算法
各个算法特点总结：[http://amao12580.github.io/index/#排序算法的特点](http://amao12580.github.io/index/#排序算法的特点)

#### 1. 合并排序算法
* 思路：
* 将数组按长度切分成均匀的碎片，直到每个碎片数组长度不超过2
* 每个碎片数组进行排序
* 合并碎片数组，每两个碎片数组进行计算，总是两个起始元素进行比较，将小的元素迁移到新数组

#### 2. 选择排序算法
* 思路：
* 在第i次迭代中，在剩下的(即未排序的)元素中找到最小的元素
* 将第i个元素与最小的元素交换位置

#### 3. 插入排序算法
*  思路：
* 在第i次迭代中，将第i个元素与每一个它左边且比它大的的元素交换位置

#### 4. 希尔排序算法
* 对插入排序的改良
* 按照不同步长对元素进行插入排序

#### 5. 快速排序算法
* 对归并排序的改良
* 将二分之一切分改为按基数进行切分为两部分，一部分都比基数小，另一部分都比基数要大。
* 在每部分中，选取新基数，再次进行按基数切分，直到所有数据有序。

#### 6. 堆排序算法
* 借用完全二叉树的思想
* 设定数组初始长度为N，将数组调整为最大堆，最大堆的根节点是最大值。
* 根节点位于数组首部，O(0)
* 将这个最大值与O(N-1)交换
* 将数组的遍历范围减一，即:N--
* 在0到N之间重复上述过程

#### 7.计数排序算法
* 一种特殊的桶排序，按照每个待排序的数值进行分桶
* 找出待排序的数组中最大和最小的元素
* 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
* 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
* 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

#### 8.桶排序算法
* 桶排序是计数排序的变种，把计数排序中相邻的m个"小桶"放到一个"大桶"中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。
* 基本思想：
* 桶排序假设序列由一个随机过程产生，该过程将元素均匀而独立地分布在区间[0,1)上。我们把区间[0,1)划分成n个相同大小的子区间，称为桶。将n个记录分布到各个桶中去。
* 如果有多于一个记录分到同一个桶中，需要进行桶内排序。最后依次把各个桶中的记录列出来记得到有序序列。
* 效率分析：
* 桶排序的平均时间复杂度为线性的O(N+C)，其中C为桶内快排的时间复杂度。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。
* 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。

#### 9. 基数排序算法
* 将所有待比较数值(注意,必须是正整数)统一为同样的数位长度,数位较短的数前面补零.
* 从最低位开始, 依次进行一次稳定排序.
* 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列.