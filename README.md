# algorithms learning
## 算法学习记录

### 32个经典算法

### 排序算法
各个算法特点总结：[http://amao12580.github.io/index/#排序算法的特点](http://amao12580.github.io/index/#排序算法的特点)

#### 1. 合并排序算法
* 思路：
* 将数组按长度切分成均匀的碎片，直到每个碎片数组长度不超过2
* 每个碎片数组进行排序
* 合并碎片数组，每两个碎片数组进行计算，总是两个起始元素进行比较，将小的元素迁移到新数组

#### 2. 选择排序算法
* 思路：
* 在第i次迭代中，在剩下的(即未排序的)元素中找到最小的元素
* 将第i个元素与最小的元素交换位置

#### 3. 插入排序算法
*  思路：
* 在第i次迭代中，将第i个元素与每一个它左边且比它大的的元素交换位置

#### 4. 希尔排序算法
* 对插入排序的改良
* 按照不同步长对元素进行插入排序

#### 5. 快速排序算法
* 对归并排序的改良
* 将二分之一切分改为按基数进行切分为两部分，一部分都比基数小，另一部分都比基数要大。
* 在每部分中，选取新基数，再次进行按基数切分，直到所有数据有序。

#### 6. 堆排序算法
* 借用完全二叉树的思想
* 设定数组初始长度为N，将数组调整为最大堆，最大堆的根节点是最大值。
* 根节点位于数组首部，O(0)
* 将这个最大值与O(N-1)交换
* 将数组的遍历范围减一，即:N--
* 在0到N之间重复上述过程

#### 7.计数排序算法
* 一种特殊的桶排序，按照每个待排序的数值进行分桶
* 找出待排序的数组中最大和最小的元素
* 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
* 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
* 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

#### 8.桶排序算法

#### 9. 基数排序算法
* 将所有待比较数值(注意,必须是正整数)统一为同样的数位长度,数位较短的数前面补零.
* 从最低位开始, 依次进行一次稳定排序.
* 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列.